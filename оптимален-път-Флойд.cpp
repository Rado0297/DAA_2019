#include<iostream>
#define inf 9999999999
#defone MAXN 128
using namespace std;
int n, m, v, u, w, a[MAXN][MAXN];

int main ()
{
    cin>>n>>m;                                  //въвеждаме N-брой върхове и M-брой ребра

    for(int i=1; i<=n; i++){                    //обхождаме всички върхове
        for(int j=1; j<=n; j++){                //обхождаме всички върхове
            a[i][j]=inf;                        //задаваме безкрайна стойност INF
        }
    }

    for(int i=0; i<m; i++){                     //колкото са ребрата
        cin>>v>>u>>w;                           //задаваме ребро между връх V и връх U с тегло (дължина) W
        a[v][u]=w;                              //отбелязваме, че реброто между V и U тежи W в матрицата на теглата
        a[u][v]=w;                              //отбелязваме, че реброто между U и V тежи W в матрицата на теглата
    }

    for(int k=1; k<=n; k++){                    //обхождаме всички върхове
        for(int i=1; i<=n; i++){                //обхождаме всички върхове
            for(int j=1; j<=n; j++){            //обхождаме всички върхове
                if(a[i][j]>a[i][k]+a[k][j])     //ако текущият път между i и j е по-дълъг от пътят от i до k и после от k до j
                    a[i][j]=a[i][k]+a[k][j];    //на текущият път се задава сбора на стойностите от пътят от i до k и пътят от k до j
            }
        }
    }
    for(int i=1; i<=n; i++)                     //обхождаме всички върхове
        a[i][i]=0;                              //най-краткият път от връх до самият себе си е 0

    for(int i=1; i<=n; i++){                    //обхождаме цялата матрица
        for(int j=1; j<=n; j++){
            cout<<a[i][j]<<" ";                 //и я печатаме
        }
        cout<<endl;
    }

    return 0;
}

/*
Алгоритъмът се използва както за неориентиран (в случая), така и за ориетиран граф. Оптимизирането става чрез трети допълнителен връх k.
Разполагаме с пътищата от всеки връх до всеки връх без допълнителен разход на памет, защото използваме самата матрица на теглата.
Сложността е О(N^3) заради трите вложени цикъла.
*/
