#include<iostream>
#define inf 9999999999
#defone MAXN 128
using namespace std;
int n, m, dp[MAXN], a[MAXN][MAXN], v, u, w, s;

int main ()
{
    cin>>n>>m;                                  //въвеждаме N-брой върхове и M-брой ребра

    for(int i=1; i<=n; i++){                    //обхождаме всички върхове
        for(int j=1; j<=n; j++)                 //обхождаме всички върхове
            a[i][j]=inf;                        //задаваме безкрайна стойност INF
    }

    for(int i=0; i<m; i++){                     //колкото са ребрата
        cin>>v>>u>>w;                           //задаваме ребро между връх V и връх U с тегло (дължина) W
        a[v][u]=w;                              //отбелязваме, че реброто между V и U тежи W в матрицата на теглата (ориентиран граф)
    }

    s=1;                                        //задаваме начален връх S (в случая - 1)
    for(int i=1; i<=n; i++){                    //обхождаме всички върхове
        dp[i]=a[s][i];                          //първоначалният път до всеки един връх е върха от S до него
    }
    dp[s]=0;                                    //най-краткия път от върха S до самия него е 0

    for(int k=0; k<n-2; k++)                    //повтаряме долната стъпка N-1 пъти
        for(int i=1; i<=n; i++){                //обхождаме всички върхове
            for(int j=1; j<=n; j++){            //обхождаме всички върхове
                if(dp[i]>dp[j]+a[j][i])         //ако теглото от началният връх до върха j, събрано с теглото на реброто от j до i е по-малко от първоначалният път до i
                    dp[i]=dp[j]+a[j][i];        //присвояваме на i сбора от j и пътя между i и j
            }
        }

    cout<<dp[n];                                //печатаме масива DP с позиция крайният връх

    return 0;
}

/*
Алгорътъмът се прилага върху ориентиран претеглен граф и намира най-късия път между зададени начален и краен връх (в случая S и N).
 Сложността му е О(N^3) задари трите вложени цикъла.
*/
