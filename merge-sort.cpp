#include<iostream>
using namespace std;
int a[128], n, L[128], R[128];

void merge(int l, int m, int r){                        //алгоритъм за сливане
    int nl=m-l+1;                                       //намираме броя на елементите от лявата страна
    int nr=r-m;                                         //и от дясната

    int i, j, k;
    for(i=0; i<nl; i++)L[i]=a[l+i];                     //на масива L присвояваме елементите отляво
    for(j=0; j<nr; j++)R[j]=a[m+1+j];                   //а на R - тези в дясно

    k=l; i=0; j=0;
    while(i<nl && j<nr){                                //докато приключим лявата или дясната страна
        if(L[i]<R[j]){                                  //сравняваме двата елемента
            a[k]=L[i];                                  //слагаме по-малкия от тях на текущата позиция в оригиналния масив
            i++;                                        //и предвиждаме указателя за позиция на левия (или десния аналогично) масив
        }
        else{
            a[k]=R[j];
            j++;
        }
        k++;                                            //преминаваме към средваща позиция в оригиналния масив
    }

    while(i<nl){                                        //ако не сме приключили левия масив
        a[k]=L[i];                                      //присвояваме останалите му елементи в края на оригиналния масив
        i++;
        k++;
    }
    while(j<nr){                                        //аналогично за десния масив
        a[k]=R[j];
        j++;
        k++;
    }
}

void mergeSort(int l, int r){                           //алгоритъм merge sort
    if(l<r){                                            //ако лявата граница е по-малка от дясната, т.е. ако имаме редица
        int m=(l+r)/2;                                  //намираме средата
        mergeSort(l, m);                                //сортираме лявата част
        mergeSort(m+1, r);                              //сортираме дясната част
        merge(l, m, r);                                 //сливаме цялата редица
    }
}


int main ()
{
    cin>>n;
    for(int i=1; i<=n; i++)cin>>a[i];
    mergeSort(0, n);
    for(int i=1; i<=n; i++)cout<<a[i]<<" ";

    return 0;
}

/*
Основната идея, както във всички D&C алгоритми, е това да разделим задачата на по-малки, които да решим последователно.
Функционалността на този алгоритъм се свежда до това да разбие основния масив на два по-малки, след това всеки от тях на два още по-малки и така,
докато достигне едноелементни масиви. След това ги слива рекурсивно по обратния ред до достигането на един обединен масив.
Предимствата пред Quick sort са доброто справяне с масив от еднакви числа. Също така са достатъчно близки като скорост, за да игнорираме този фактор.
Недостатъкът е най-вече допълнителната памет, изисквана по време на изпълнение на програмата.
Сложността на алгоритъма е O(n log(n)).
*/
